#!/usr/bin/env bash

ID_COLOUR="\033[36m"
TEXT_COLOUR="\033[34m"
STATUS_COLOUR="\033[33m"
SHELL_COLOUR="\033[0m"


my_issues() {
  local repo="${1:-HubSpot/Billing-Management-Team}"
  # gh issue list --label 'FE' --assignee '@me' --repo HubSpot/Merchant-Experience-Team
  local issue_list=$(GH_FORCE_TTY=true gh issue list --label 'FE' --repo "$repo" --assignee '@me')

  if [[ -z $issue_list ]]; then
    return 1
  fi

  if [[ ${issue_list} == no* ]]; then
    return 1
  fi

  local issue="$(echo "$issue_list" | awk -F'\t' -v ID_COLOUR="$ID_COLOUR" -v TEXT_COLOUR="$TEXT_COLOUR" -v STATUS_COLOUR="$STATUS_COLOUR" -v SHELL_COLOUR="$SHELL_COLOUR" \
    '{print ID_COLOUR $1 SHELL_COLOUR"\t"TEXT_COLOUR $3 SHELL_COLOUR"\t"STATUS_COLOUR $2}' |
    fzf -d' ' \
      --ansi \
      --prompt="my issues in $repo:")"

  echo "$issue" | cut -f-2
  #xargs -n1 gh issue view -R "$repo" -c
}

make_branch() {
  local issue=$(my_issues)
  local exit_code="$?"
  if [[ $exit_code -gt 0 ]]; then
    echoerr "No issues found"
    return 1
  fi

  if [[ -z $issue ]]; then
    echoerr "No issue selected"
    return 1
  fi
  echo "would have made branch for $issue"
  # gitb "$issue"
}

gch() {
 git checkout "$(git branch --all | fzf | tr -d '[:space:]')"
}

# make a note in the notes directory
nn() {
  local note_name="$*"
  local note_date="`date +%F`"
  local note_ext="md"
  if [[ $note_name == "" ]]; then
    note_name="$note_date.$note_ext"
  else
    note_name="$note_name.$note_ext"
  fi
  mkdir -p $ATLAS_NOTES_DIR
  v "$ATLAS_NOTES_DIR/$note_name"
}

# search note contents for a term
ns() {
  local DIR="$ATLAS_NOTES_DIR"
  local RG_PREFIX="rg --column --line-number --no-heading --color=always --smart-case -tmd "
  local INITIAL_QUERY="${*:-}"
  : | fzf --ansi --disabled --query "$INITIAL_QUERY" \
    --bind "start:reload:$RG_PREFIX {q} '$DIR'" \
    --bind "change:reload:sleep 0.1; $RG_PREFIX {q} '$DIR' || true" \
    --delimiter : \
    --preview 'bat --color=always {1} --highlight-line {2}' \
    --preview-window 'right,60%,border-bottom,+{2}+3/3,~3' \
    --bind 'enter:become(nvim {1} +{2})'
}


# search note filenames
nl() {
  local files
  files="$(rg --files $ATLAS_NOTES_DIR | fzf --delimiter / --with-nth -1 --preview "head -100 {} ")"
  if [[ -n $files ]]; then
    v $files
  fi
}


alias rgf='rg --files | rg'

# search repos
rs() {
  local files="$(rg --files ~/repos | fzf --delimiter / --with-nth -1 --preview 'bat --color=always {}')"
  if [[ -n $files ]]; then
    v $files
  fi

}

cs() {
  local DIR="~/repos"
  local RG_PREFIX="rg --files $DIR | rg --column --line-number --no-heading --color=always --smart-case -g '!*test.*' -g '!static/test/*' "
  local INITIAL_QUERY="${*:-}"
  : | fzf --ansi --disabled --query "$INITIAL_QUERY" \
    --bind "start:reload:$RG_PREFIX {q} $DIR" \
    --bind "change:reload:sleep 0.1; $RG_PREFIX {q} $DIR || true" \
    --delimiter : \
    --preview 'bat --color=always {1} --highlight-line {2}' \
    --bind 'enter:become(code {1} +{2})'
}

# Create a new directory and enter it
mkd() {
  mkdir -p "$@" && cd "$_";
}

# Determine size of a file or total size of a directory
fs() {
  if du -b /dev/null > /dev/null 2>&1; then
    local arg=-sbh;
  else
    local arg=-sh;
  fi
  if [[ -n "$@" ]]; then
    du $arg -- "$@";
  else
    du $arg .[^.]* ./*;
  fi;
}

# Create a data URL from a file
dataurl() {
  local mimeType=$(file -b --mime-type "$1");
  if [[ $mimeType == text/* ]]; then
    mimeType="${mimeType};charset=utf-8";
  fi
  echo "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')";
}

# `v` with no arguments opens the current directory in Neovim, otherwise opens the
# given location
v() {
  if [ $# -eq 0 ]; then
    $EDITOR;
  else
    $EDITOR "$@";
  fi;
}

# `tre` is a shorthand for `tree` with hidden files and color enabled, ignoring
# the `.git` directory, listing directories first. The output gets piped into
# `less` with options to preserve color and line numbers, unless the output is
# small enough for one screen.
tre() {
  tree -aC -I '.git|node_modules|bower_components' --dirsfirst "$@" | less -FRNX;
}

# Copy website and its contents
copy_website () {
  wget -e robots=off -p -k "$1"
}

# Extract most know archives with one command
extract () {
if [ -f $1 ]; then
  case $1 in
    *.tar.bz2)	tar xjf $1;;
    *.tar.gz)	tar xzf $1;;
    *.bz2)		bunzip2 $1;;
    *.rar)		unrar e $1;;
    *.gz)		gunzip $1;;
    *.tar)		tar xf $1;;
    *.tbz2)		tar xjf $1;;
    *.tgz)		tar xzf $1;;
    *.zip)		unzip $1;;
    *.Z)		uncompress $1;;
    *.7z)		7z x $1;;
    *)			echo "'$1' cannot be extracted via extract()" ;;
  esac
else
  echo "'$1' is not a valid file"
fi
}

# download a file from $1 and save it in a file $2
dl() {
  curl "$1" --output "~/Downloads/$2"
}

banner() {
  figlet -f banner "$1" | sed -e "s/#/:${2}:/g" | sed -e 's/ /:blank:/g' | pbcopy
}

##########
# TMUX
##########

unbool() {
  tmux kill-server
}

bool() {
  local SESSION_NAME="Bool"
  tmux has-session -t $SESSION_NAME 2>/dev/null

  if [[ $? != 0 ]]; then
    # Start New Session with our name
    tmux new-session -t "$SESSION_NAME" -d

    # Name first Window and start zsh
    tmux rename-window -t 1 'üåÄ'

    # Create and setup panes
    local two='üåÆ'
    tmux new-window -t "$SESSION_NAME":2 -n "$two"
    tmux send-keys -t "$two" "cd ~/repos && clear" C-m

    local three='üí£'
    tmux new-window -t "$SESSION_NAME":3 -n "$three"
    tmux send-keys -t "$three" "cd ~/repos && clear" C-m

    local four='üíé'
    tmux new-window -t "$SESSION_NAME":4 -n "$four"
    tmux send-keys -t "$four" "cd ~/repos && clear" C-m

    local five='ü™ù'
    tmux new-window -t "$SESSION_NAME":5 -n "$five"
    tmux send-keys -t "$five" "cd ~/repos && clear" C-m

    local six='üß©'
    tmux new-window -t "$SESSION_NAME":6 -n "$six"
    tmux send-keys -t "$six" "cd ~/repos && clear" C-m
  fi

  # Attach Session, on the Main window
  tmux a -t "$SESSION_NAME"
}

##########
# FFMPEG
##########

convert_aiffs() {
  for i in *.aiff;
    do convert_aiff $i;
  done
}

convert_aiff() {
  ffmpeg -hide_banner -loglevel error -y -i "$1" -c:a libvorbis -q:a 4 "_$1.ogg";
}

convert_gifs() {
  for i in *.gif;
    do convert_gif $i;
  done
}

convert_gif() {
  ffmpeg -hide_banner -loglevel error -y -f gif -i "$1" -movflags faststart -pix_fmt yuv420p -vf "scale=trunc(iw/2)*2:trunc(ih/2)*2" "_${1.*}.mp4";
}

convert_webms() {
  for i in *.webm;
    do convert_webm $i;
  done
}

convert_webm() {
  echo "Converting $1"
  # ffmpeg -fflags +genpts -i "$1" -r 24 "scale=trunc(iw/2)*2:trunc(ih/2)*2" "_${1.*}.mp4"
  ffmpeg -hide_banner -loglevel error -fflags +genpts -i "$1" -vf "pad=ceil(iw/2)*2:ceil(ih/2)*2" -r 24 "${1%.*}.mp4"
}


##########
# Utilities
##########

colortest() {
  awk 'BEGIN{
    s="/\\/\\/\\/\\/\\"; s=s s s s s s s s s s s s s s s s s s s s s s s;
    for (colnum = 0; colnum<256; colnum++) {
      r = 255-(colnum*255/255);
      g = (colnum*510/255);
      b = (colnum*255/255);
      if (g>255) g = 510-g;
      printf "\033[48;2;%d;%d;%dm", r,g,b;
      printf "\033[38;2;%d;%d;%dm", 255-r,255-g,255-b;
      printf "%s\033[0m", substr(s,colnum+1,1);
    }
    printf "\n";
  }'
}

rename_files() {
  local old=$1
  local new=$2
  find . -name "*.$old" -exec bash -c 'mv "$1" "${1%.$old}".$new' - '{}' +
}

confirm() {
  # call with a prompt string or use a default
  read -r -p "${1:-Are you sure? [y/N]} " response
  case "$response" in
      [yY][eE][sS]|[yY])
          true
          ;;
      *)
          false
          ;;
  esac
}

##########
# Git
##########

# get default branch name (branch you should branch from for new work)
gdefault() {
  command git branch -rl '*/HEAD' | rev | cut -d/ -f1 | rev
}

# publish local branch
gpub() {
  command git push --set-upstream origin $(git_current_branch)
}

gcr() {
  command git checkout -t origin/"${@}"
}

# Clean up local branches that have been merged
function gclean() {
  branch=$1
  if [[ -z "$branch" ]]; then
    branch=$(gdefault)
  fi
  confirm "Are you on a clean branch?" &&
  command git checkout "$branch" &&
  command git branch -d $(command git branch --merged="$branch" | grep -v "$branch") &&
  command git fetch --prune
}

# Create a new branch and switch to it
gitb() {
  # [          # start of character class
  # [:space:]  # The POSIX character class for whitespace characters. It's
               # functionally identical to [ \t\r\n\v\f] which matches a space,
               # tab, carriage return, newline, vertical tab, or form feed. See
               # https://en.wikipedia.org/wiki/Regular_expression#POSIX_character_classes
  # ]          # end of character class
  # \+         # one or more of the previous item (anything matched in the brackets).
  local branchname=$(echo $1 | sed 's/-//g' | sed -re 's/[[:blank:]]/-/g')
   if [[ $branchname = no-issue-found* ]]; then
    echo "No issues found."
    return 1
  fi
  # local datestr=$(date +%F)
  branchname=$(echo "$USER"/"$branchname")
  git checkout -b $branchname
}


# Create a new tag and push it to origin
tag() {
  command git checkout master
  command git pull origin master
  command git fetch --tags
  command git tag -a "$1" -m "Release $1"
  command git push origin "$1" --tag
}

# print a random icebreaker question
icebreaker() {
  node "$ATLAS_ROOT/scripts/icebreaker.js"
}

# open the neovim log file
nvim_logs() {
  nvim ~/.cache/nvim
}

####################################################
# HUBSPOT
####################################################
# Set to the directory you typically clone your git repos
HUBSPOT_CODE_DIR="$HOME/repos"

# Completion for repo
# _repo_comp() {
#   reply=(`ls $HUBSPOT_CODE_DIR`);
# }

is_inside_git_repo() {
    git rev-parse --is-inside-work-tree >/dev/null 2>&1
}

# clone a repo if it doesn't exist
# @example
# repo some-repo-name
repo() {
  if [ ! -d "$HUBSPOT_CODE_DIR/$1" ]; then
    echo "‚ö†Ô∏è Repo missing: \"$1\", cloning into $HUBSPOT_CODE_DIR/$1"
    cd $HUBSPOT_CODE_DIR
    git clone "git@git.hubteam.com:HubSpot/$1.git" || git clone "git@git.hubteam.com:HubSpotProtected/$1.git" || echo "üö® uh oh, something went wrong cloning $1" && exit $EXITCODE
  fi
  if [ -d "$HUBSPOT_CODE_DIR/$1" ]; then
    cd $HUBSPOT_CODE_DIR/$1
  fi
}

# add completion for repos in $HUBSPOT_CODE_DIR
# https://zsh.sourceforge.io/Doc/Release/Completion-Using-compctl.html
# compctl -M 'm:{a-z}={A-Z}' -K _repo_comp repo

# pulls latest changes from remote if there are any
# stores the current branch name and then switches to the master branch
# switches to the branch name after updating from master
# does nothing if branch is dirty
update_repo() {
  local branch=$(git_current_branch)
  local isrepo=$(git status 2>/dev/null; echo $?)
  # if the branch is dirty, don't update
  if [[ $(git diff --stat) != '' ]]; then
    echo "‚ö†Ô∏è '$(pwd)' is dirty, skipping..."
  else
    git checkout master &> /dev/null
    git pull &> /dev/null
    git checkout "$branch" &>/dev/null
  fi
}

# update all repos in $HUBSPOT_CODE_DIR
update_repos() {
  for dir in $HUBSPOT_CODE_DIR/*; do
    [[ -d "$dir" ]] || continue
    {
      cd "$dir" && is_inside_git_repo && update_repo
    }
  done
}

# tail the asset bender log file
tail_bend_logs() {
  tail -f ~/.cache/nvim/asset-bender.log
}

# run prettier on all staged files
pretty() {
  bpx hs-prettier --write $(git diff --name-only --cached)
}

# run hs projects with my preferred settings
flexo() {
  cd "$HUBSPOT_CODE_DIR" &&\
  NODE_OPTIONS="--max_old_space_size=8192"\
  bend reactor serve\
    --UNSUPPORTED_LOCAL_DEV_SETTING bend-webpack.enableFastRefresh\
    --UNSUPPORTED_LOCAL_DEV_SETTING bend-webpack.useWebpack5 "$@"\
    --update\
    --ts-watch
}
