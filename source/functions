#!/usr/bin/env bash

edit_file() {
	previous_file="$1"
	file_to_edit=`select_file $previous_file`

	if [ -n "$file_to_edit" ] ; then
		"$EDITOR" "$file_to_edit"
		edit_file "$file_to_edit"
	fi
}

cat() {
   if hash bat 2>/dev/null; then
        bat -pp "$@"
   else
        command cat "$@"
   fi
}

select_file() {
	given_file="$1"
	fzf --preview="cat {}" --preview-window=right:70%:wrap --query="$given_file"
}

# gh issue list --label "Front End" --assignee "@me" --repo HubSpot/Merchant-Experience-Team
ghe_issues() {
	local repo="$1"
	if [ -z "$repo" ]; then
    repo='HubSpot/Merchant-Experience-Team'
  fi
	gh issue list --label 'Front End' --assignee '@me' --repo "$repo" --json 'title'
}

make_branch() {
		ghe_issues | echo |
    sed -e 's/"\(.*\)"/\1/' -e 's/\\t/\t/' |
    fzf \
      --with-nth=1 \
      --delimiter='\t' \
      --preview='echo -e {2}' \
      --preview-window=top:wrap |
    cut -f1 |
    sed -e 's/\. /\t/' -e 's/[^a-zA-Z0-9\t]/-/g' |
    awk '{printf "%s/%s", $1, tolower($2)}' | echo
}

gch() {
 git checkout "$(git branch --all | fzf | tr -d '[:space:]')"
}

pr_checkout() {
  local jq_template pr_number

  jq_template='"'\
'#\(.number) - \(.title)'\
'\t'\
'Author: \(.user.login)\n'\
'Created: \(.created_at)\n'\
'Updated: \(.updated_at)\n\n'\
'\(.body)'\
'"'

  pr_number=$(
    gh api 'repos/:owner/:repo/pulls' |
    jq ".[] | $jq_template" |
    sed -e 's/"\(.*\)"/\1/' -e 's/\\t/\t/' |
    fzf \
      --with-nth=1 \
      --delimiter='\t' \
      --preview='echo -e {2}' \
      --preview-window=top:wrap |
    sed 's/^#\([0-9]\+\).*/\1/'
  )

  if [ -n "$pr_number" ]; then
    gh pr checkout "$pr_number"
  fi
}

nn() {
	local note_name="$*"
	local note_date="`date +%F`"
	local note_ext="md"
	if [[ $note_name == "" ]]; then
		note_name="$note_date.$note_ext"
	else
		note_name="$note_name.$note_ext"
	fi
	mkdir -p $ATLAS_NOTES_DIR
	v "$ATLAS_NOTES_DIR/$note_name"
}

ns() {
  local file
  [ -z "$1" ] && echo "No argument supplied - Enter a term to search" && return 1
  file="$(rg --files-with-matches --no-ignore --ignore-case --hidden --no-heading --no-messages $1 $ATLAS_NOTES_DIR | fzf --preview "head -100 {}")"
  if [[ -n $file ]]
  then
    v $file
  fi
}

nl() {
  local files
  files="$(rg --files $ATLAS_NOTES_DIR | fzf --preview "head -100 {}")"
  if [[ -n $files ]]; then
v $files
  fi
}

# Create a new directory and enter it
mkd() {
	mkdir -p "$@" && cd "$_";
}

# Determine size of a file or total size of a directory
fs() {
	if du -b /dev/null > /dev/null 2>&1; then
		local arg=-sbh;
	else
		local arg=-sh;
	fi
	if [[ -n "$@" ]]; then
		du $arg -- "$@";
	else
		du $arg .[^.]* ./*;
	fi;
}

# Create a data URL from a file
dataurl() {
	local mimeType=$(file -b --mime-type "$1");
	if [[ $mimeType == text/* ]]; then
		mimeType="${mimeType};charset=utf-8";
	fi
	echo "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')";
}

# `v` with no arguments opens the current directory in Neovim, otherwise opens the
# given location
v() {
	if [ $# -eq 0 ]; then
		$EDITOR;
	else
		$EDITOR "$@";
	fi;
}

# `tre` is a shorthand for `tree` with hidden files and color enabled, ignoring
# the `.git` directory, listing directories first. The output gets piped into
# `less` with options to preserve color and line numbers, unless the output is
# small enough for one screen.
tre() {
	tree -aC -I '.git|node_modules|bower_components' --dirsfirst "$@" | less -FRNX;
}

# Copy website and its contents
copy_website () {
	wget -e robots=off -p -k "$1"
}

# Extract most know archives with one command
extract () {
if [ -f $1 ]; then
	case $1 in
		*.tar.bz2)	tar xjf $1;;
		*.tar.gz)	tar xzf $1;;
		*.bz2)		bunzip2 $1;;
		*.rar)		unrar e $1;;
		*.gz)		gunzip $1;;
		*.tar)		tar xf $1;;
		*.tbz2)		tar xjf $1;;
		*.tgz)		tar xzf $1;;
		*.zip)		unzip $1;;
		*.Z)		uncompress $1;;
		*.7z)		7z x $1;;
		*)			echo "'$1' cannot be extracted via extract()" ;;
	esac
else
	echo "'$1' is not a valid file"
fi
}

dl() {
  curl "$1" --output "$2"
}

mdless() {
	pandoc -s -f markdown -t man $1 | groff -T utf8 -man | less
}

umedit() {
	mkdir -p ${ATLAS_DEV_DIR}; v ${ATLAS_DEV_DIR}/$1;
}

um() { mdless ${ATLAS_DEV_DIR}"$1"; }

umls() { ls ${ATLAS_DEV_DIR} }

banner() {
	figlet -f banner "$1" | sed -e "s/#/:${2}:/g" | sed -e 's/ /:blank:/g' | pbcopy
}

webpage_to_org() {
	if [[ -z $1 ]]; then
		echo "must provide a website"
		return 1
	fi
	if [[ -z $2 ]]; then
		echo "must provide a output filename (without extension)"
		return 1
	fi
	curl -sL ${1} | pandoc -o ${2}.org --from=html --to=org
}


##########
# TMUX
##########

unbool() {
	tmux kill-server
}

bool() {
	local SESSION_NAME="Bool"
	tmux has-session -t $SESSION_NAME 2>/dev/null

	if [[ $? != 0 ]]; then
		# Start New Session with our name
		tmux new-session -t "$SESSION_NAME" -d

		# Name first Window and start zsh
		tmux rename-window -t 1 'üåÄ'

		# Create and setup panes
		local two='üåÆ'
		tmux new-window -t "$SESSION_NAME":2 -n "$two"
		tmux send-keys -t "$two" "cd ~/repos && clear" C-m

		local three='üí£'
		tmux new-window -t "$SESSION_NAME":3 -n "$three"
		tmux send-keys -t "$three" "cd ~/repos && clear" C-m

		local four='üíé'
		tmux new-window -t "$SESSION_NAME":4 -n "$four"
		tmux send-keys -t "$four" "cd ~/repos && clear" C-m

		local five='ü™ù'
		tmux new-window -t "$SESSION_NAME":5 -n "$five"
		tmux send-keys -t "$five" "cd ~/repos && clear" C-m

		local six='üß©'
		tmux new-window -t "$SESSION_NAME":6 -n "$six"
		tmux send-keys -t "$six" "cd ~/repos && clear" C-m
	fi

	# Attach Session, on the Main window
	tmux a -t "$SESSION_NAME"
}

##########
# FFMPEG
##########

convert_aiffs() {
	for i in *.aiff;
		do convert_aiff $i;
	done
}

convert_aiff() {
	ffmpeg -hide_banner -loglevel error -y -i "$1" -c:a libvorbis -q:a 4 "_$1.ogg";
}

convert_gifs() {
	for i in *.gif;
		do convert_gif $i;
	done
}

convert_gif() {
	ffmpeg -hide_banner -loglevel error -y -f gif -i "$1" -movflags faststart -pix_fmt yuv420p -vf "scale=trunc(iw/2)*2:trunc(ih/2)*2" "_${1.*}.mp4";
}

convert_webms() {
	for i in *.webm;
		do convert_webm $i;
	done
}

convert_webm() {
	echo "Converting $1"
	# ffmpeg -fflags +genpts -i "$1" -r 24 "scale=trunc(iw/2)*2:trunc(ih/2)*2" "_${1.*}.mp4"
	ffmpeg -hide_banner -loglevel error -fflags +genpts -i "$1" -vf "pad=ceil(iw/2)*2:ceil(ih/2)*2" -r 24 "${1%.*}.mp4"
}


##########
# Utilities
##########

colortest() {
	awk 'BEGIN{
		s="/\\/\\/\\/\\/\\"; s=s s s s s s s s s s s s s s s s s s s s s s s;
		for (colnum = 0; colnum<256; colnum++) {
			r = 255-(colnum*255/255);
			g = (colnum*510/255);
			b = (colnum*255/255);
			if (g>255) g = 510-g;
			printf "\033[48;2;%d;%d;%dm", r,g,b;
			printf "\033[38;2;%d;%d;%dm", 255-r,255-g,255-b;
			printf "%s\033[0m", substr(s,colnum+1,1);
		}
		printf "\n";
	}'
}

dump_ifit_mongo() {
    docker exec mongodb ~/.atlas/scripts/dump-mongo
}

rename_files() {
	local old=$1
	local new=$2
	find . -name "*.$old" -exec bash -c 'mv "$1" "${1%.$old}".$new' - '{}' +
}

confirm() {
    # call with a prompt string or use a default
    read -r -p "${1:-Are you sure? [y/N]} " response
    case "$response" in
        [yY][eE][sS]|[yY])
            true
            ;;
        *)
            false
            ;;
    esac
}

##########
# Git
##########

# get default branch name (branch you should branch from for new work)
gdefault() {
	command git branch -rl '*/HEAD' | rev | cut -d/ -f1 | rev
}

# publish local branch
gpub() {
	command git push --set-upstream origin $(git_current_branch)
}

gcr() {
	command git checkout -t origin/"${@}"
}

# Clean up local branches that have been merged
function gclean() {
	branch=$1
	if [[ -z "$branch" ]] then
		branch=$(gdefault)
	fi
	confirm "Are you on a clean branch?" &&
	command git checkout "$branch" &&
	command git branch -d $(command git branch --merged="$branch" | grep -v "$branch") &&
	command git fetch --prune
}

gitb() {
  local branchname=$(echo $@ | sed 's/ /-/g')
  local datestr=$(date +%F)
  branchname=$(echo "$USER"/"$branchname")
  git checkout -b $branchname
}


tag() {
    command git checkout master
    command git pull origin master
    command git fetch --tags
    command git tag -a "$1" -m "Release $1"
    command git push origin "$1" --tag
}

icebreaker() {
	node "$ATLAS_ROOT/scripts/icebreaker.js"
}

####################################################
# HUBSPOT
####################################################
# Set to the directory you typically clone your git repos
HUBSPOT_CODE_DIR="$HOME/repos"

# Completion for repo
_repo_comp() {
  reply=(`ls $HUBSPOT_CODE_DIR`);
}

repo() {
  # if [ ! -d "$HUBSPOT_CODE_DIR/$1" ]; then
  #   echo "‚ö†Ô∏è Repo missing: \"$1\", cloning into $HUBSPOT_CODE_DIR/$1"
  #   cd $HUBSPOT_CODE_DIR
  #   git clone "git@git.hubteam.com:HubSpot/$1.git" || git clone "git@git.hubteam.com:HubSpotProtected/$1.git" || echo "üö® uh oh, something went wrong cloning $1" && exit $EXITCODE
  # fi
  # if [ -d "$HUBSPOT_CODE_DIR/$1" ]; then
  #   cd $HUBSPOT_CODE_DIR/$1
  # fi
  ~/.config/atlas/scripts/repo.ts "$1"
}

compctl -M 'm:{a-z}={A-Z}' -K _repo_comp repo

# pulls latest changes from remote if there are any
# stores the current branch name and then switches to the master branch
# switches to the branch name after updating from master
# does nothing if branch is dirty
update_repo() {
  local branch=$(git_current_branch)
  # if the branch is dirty, don't update
  if [[ $(git diff --stat) != '' ]]; then
    echo "‚ö†Ô∏è '$(pwd)' is dirty, skipping..."
  else
    git checkout master &> /dev/null
    git pull &> /dev/null
    git checkout "$branch" &>/dev/null
  fi
}

update_repos() {
  for i in $HUBSPOT_CODE_DIR/*;
    do cd $i && update_repo;
  done
}

tail_bend_logs() {
	tail -f ~/.cache/nvim/asset-bender.log
}

nvim_logs() {
	nvim /Users/tatlas/.cache/nvim
}

pretty() {
  bpx hs-prettier --write $(git diff --name-only --cached)
}

